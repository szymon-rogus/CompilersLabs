Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADD_ASSIGN
    BREAK
    COMMA
    COMMENT
    CONTINUE
    DIVIDE_ASSIGN
    ELSE
    EQUALS
    EYE
    FOR
    GREATER
    GREATER_EQUALS
    IF
    LBRACE
    LESSER
    LESSER_EQUALS
    LSQUARE
    MDIVIDE
    MMINUS
    MPLUS
    MTIMES
    MULTIPLY_ASSIGN
    NOT_EQUALS
    ONES
    PRINT
    RANGE
    RBRACE
    RETURN
    RSQUARE
    SEMICOLON
    STRING
    SUBSTRACT_ASSIGN
    THEN
    TRANSPOSITION
    WHILE
    ZEROS

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> EXPRESSION
Rule 2     EXPRESSION -> LBRACKET EXPRESSION RBRACKET
Rule 3     EXPRESSION -> INT
Rule 4     EXPRESSION -> FLOAT
Rule 5     EXPRESSION -> ID
Rule 6     EXPRESSION -> EXPRESSION PLUS EXPRESSION
Rule 7     EXPRESSION -> EXPRESSION MINUS EXPRESSION
Rule 8     EXPRESSION -> EXPRESSION TIMES EXPRESSION
Rule 9     EXPRESSION -> EXPRESSION DIVIDE EXPRESSION
Rule 10    EXPRESSION -> EXPRESSION ASSIGN EXPRESSION

Terminals, with rules where they appear

ADD_ASSIGN           : 
ASSIGN               : 10
BREAK                : 
COMMA                : 
COMMENT              : 
CONTINUE             : 
DIVIDE               : 9
DIVIDE_ASSIGN        : 
ELSE                 : 
EQUALS               : 
EYE                  : 
FLOAT                : 4
FOR                  : 
GREATER              : 
GREATER_EQUALS       : 
ID                   : 5
IF                   : 
INT                  : 3
LBRACE               : 
LBRACKET             : 2
LESSER               : 
LESSER_EQUALS        : 
LSQUARE              : 
MDIVIDE              : 
MINUS                : 7
MMINUS               : 
MPLUS                : 
MTIMES               : 
MULTIPLY_ASSIGN      : 
NOT_EQUALS           : 
ONES                 : 
PLUS                 : 6
PRINT                : 
RANGE                : 
RBRACE               : 
RBRACKET             : 2
RETURN               : 
RSQUARE              : 
SEMICOLON            : 
STRING               : 
SUBSTRACT_ASSIGN     : 
THEN                 : 
TIMES                : 8
TRANSPOSITION        : 
WHILE                : 
ZEROS                : 
error                : 

Nonterminals, with rules where they appear

EXPRESSION           : 1 2 6 6 7 7 8 8 9 9 10 10
PROGRAM              : 0

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . EXPRESSION
    (2) EXPRESSION -> . LBRACKET EXPRESSION RBRACKET
    (3) EXPRESSION -> . INT
    (4) EXPRESSION -> . FLOAT
    (5) EXPRESSION -> . ID
    (6) EXPRESSION -> . EXPRESSION PLUS EXPRESSION
    (7) EXPRESSION -> . EXPRESSION MINUS EXPRESSION
    (8) EXPRESSION -> . EXPRESSION TIMES EXPRESSION
    (9) EXPRESSION -> . EXPRESSION DIVIDE EXPRESSION
    (10) EXPRESSION -> . EXPRESSION ASSIGN EXPRESSION

    LBRACKET        shift and go to state 3
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    ID              shift and go to state 6

    PROGRAM                        shift and go to state 1
    EXPRESSION                     shift and go to state 2

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> EXPRESSION .
    (6) EXPRESSION -> EXPRESSION . PLUS EXPRESSION
    (7) EXPRESSION -> EXPRESSION . MINUS EXPRESSION
    (8) EXPRESSION -> EXPRESSION . TIMES EXPRESSION
    (9) EXPRESSION -> EXPRESSION . DIVIDE EXPRESSION
    (10) EXPRESSION -> EXPRESSION . ASSIGN EXPRESSION

    $end            reduce using rule 1 (PROGRAM -> EXPRESSION .)
    PLUS            shift and go to state 7
    MINUS           shift and go to state 8
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 10
    ASSIGN          shift and go to state 11


state 3

    (2) EXPRESSION -> LBRACKET . EXPRESSION RBRACKET
    (2) EXPRESSION -> . LBRACKET EXPRESSION RBRACKET
    (3) EXPRESSION -> . INT
    (4) EXPRESSION -> . FLOAT
    (5) EXPRESSION -> . ID
    (6) EXPRESSION -> . EXPRESSION PLUS EXPRESSION
    (7) EXPRESSION -> . EXPRESSION MINUS EXPRESSION
    (8) EXPRESSION -> . EXPRESSION TIMES EXPRESSION
    (9) EXPRESSION -> . EXPRESSION DIVIDE EXPRESSION
    (10) EXPRESSION -> . EXPRESSION ASSIGN EXPRESSION

    LBRACKET        shift and go to state 3
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    ID              shift and go to state 6

    EXPRESSION                     shift and go to state 12

state 4

    (3) EXPRESSION -> INT .

    PLUS            reduce using rule 3 (EXPRESSION -> INT .)
    MINUS           reduce using rule 3 (EXPRESSION -> INT .)
    TIMES           reduce using rule 3 (EXPRESSION -> INT .)
    DIVIDE          reduce using rule 3 (EXPRESSION -> INT .)
    ASSIGN          reduce using rule 3 (EXPRESSION -> INT .)
    $end            reduce using rule 3 (EXPRESSION -> INT .)
    RBRACKET        reduce using rule 3 (EXPRESSION -> INT .)


state 5

    (4) EXPRESSION -> FLOAT .

    PLUS            reduce using rule 4 (EXPRESSION -> FLOAT .)
    MINUS           reduce using rule 4 (EXPRESSION -> FLOAT .)
    TIMES           reduce using rule 4 (EXPRESSION -> FLOAT .)
    DIVIDE          reduce using rule 4 (EXPRESSION -> FLOAT .)
    ASSIGN          reduce using rule 4 (EXPRESSION -> FLOAT .)
    $end            reduce using rule 4 (EXPRESSION -> FLOAT .)
    RBRACKET        reduce using rule 4 (EXPRESSION -> FLOAT .)


state 6

    (5) EXPRESSION -> ID .

    PLUS            reduce using rule 5 (EXPRESSION -> ID .)
    MINUS           reduce using rule 5 (EXPRESSION -> ID .)
    TIMES           reduce using rule 5 (EXPRESSION -> ID .)
    DIVIDE          reduce using rule 5 (EXPRESSION -> ID .)
    ASSIGN          reduce using rule 5 (EXPRESSION -> ID .)
    $end            reduce using rule 5 (EXPRESSION -> ID .)
    RBRACKET        reduce using rule 5 (EXPRESSION -> ID .)


state 7

    (6) EXPRESSION -> EXPRESSION PLUS . EXPRESSION
    (2) EXPRESSION -> . LBRACKET EXPRESSION RBRACKET
    (3) EXPRESSION -> . INT
    (4) EXPRESSION -> . FLOAT
    (5) EXPRESSION -> . ID
    (6) EXPRESSION -> . EXPRESSION PLUS EXPRESSION
    (7) EXPRESSION -> . EXPRESSION MINUS EXPRESSION
    (8) EXPRESSION -> . EXPRESSION TIMES EXPRESSION
    (9) EXPRESSION -> . EXPRESSION DIVIDE EXPRESSION
    (10) EXPRESSION -> . EXPRESSION ASSIGN EXPRESSION

    LBRACKET        shift and go to state 3
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    ID              shift and go to state 6

    EXPRESSION                     shift and go to state 13

state 8

    (7) EXPRESSION -> EXPRESSION MINUS . EXPRESSION
    (2) EXPRESSION -> . LBRACKET EXPRESSION RBRACKET
    (3) EXPRESSION -> . INT
    (4) EXPRESSION -> . FLOAT
    (5) EXPRESSION -> . ID
    (6) EXPRESSION -> . EXPRESSION PLUS EXPRESSION
    (7) EXPRESSION -> . EXPRESSION MINUS EXPRESSION
    (8) EXPRESSION -> . EXPRESSION TIMES EXPRESSION
    (9) EXPRESSION -> . EXPRESSION DIVIDE EXPRESSION
    (10) EXPRESSION -> . EXPRESSION ASSIGN EXPRESSION

    LBRACKET        shift and go to state 3
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    ID              shift and go to state 6

    EXPRESSION                     shift and go to state 14

state 9

    (8) EXPRESSION -> EXPRESSION TIMES . EXPRESSION
    (2) EXPRESSION -> . LBRACKET EXPRESSION RBRACKET
    (3) EXPRESSION -> . INT
    (4) EXPRESSION -> . FLOAT
    (5) EXPRESSION -> . ID
    (6) EXPRESSION -> . EXPRESSION PLUS EXPRESSION
    (7) EXPRESSION -> . EXPRESSION MINUS EXPRESSION
    (8) EXPRESSION -> . EXPRESSION TIMES EXPRESSION
    (9) EXPRESSION -> . EXPRESSION DIVIDE EXPRESSION
    (10) EXPRESSION -> . EXPRESSION ASSIGN EXPRESSION

    LBRACKET        shift and go to state 3
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    ID              shift and go to state 6

    EXPRESSION                     shift and go to state 15

state 10

    (9) EXPRESSION -> EXPRESSION DIVIDE . EXPRESSION
    (2) EXPRESSION -> . LBRACKET EXPRESSION RBRACKET
    (3) EXPRESSION -> . INT
    (4) EXPRESSION -> . FLOAT
    (5) EXPRESSION -> . ID
    (6) EXPRESSION -> . EXPRESSION PLUS EXPRESSION
    (7) EXPRESSION -> . EXPRESSION MINUS EXPRESSION
    (8) EXPRESSION -> . EXPRESSION TIMES EXPRESSION
    (9) EXPRESSION -> . EXPRESSION DIVIDE EXPRESSION
    (10) EXPRESSION -> . EXPRESSION ASSIGN EXPRESSION

    LBRACKET        shift and go to state 3
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    ID              shift and go to state 6

    EXPRESSION                     shift and go to state 16

state 11

    (10) EXPRESSION -> EXPRESSION ASSIGN . EXPRESSION
    (2) EXPRESSION -> . LBRACKET EXPRESSION RBRACKET
    (3) EXPRESSION -> . INT
    (4) EXPRESSION -> . FLOAT
    (5) EXPRESSION -> . ID
    (6) EXPRESSION -> . EXPRESSION PLUS EXPRESSION
    (7) EXPRESSION -> . EXPRESSION MINUS EXPRESSION
    (8) EXPRESSION -> . EXPRESSION TIMES EXPRESSION
    (9) EXPRESSION -> . EXPRESSION DIVIDE EXPRESSION
    (10) EXPRESSION -> . EXPRESSION ASSIGN EXPRESSION

    LBRACKET        shift and go to state 3
    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    ID              shift and go to state 6

    EXPRESSION                     shift and go to state 17

state 12

    (2) EXPRESSION -> LBRACKET EXPRESSION . RBRACKET
    (6) EXPRESSION -> EXPRESSION . PLUS EXPRESSION
    (7) EXPRESSION -> EXPRESSION . MINUS EXPRESSION
    (8) EXPRESSION -> EXPRESSION . TIMES EXPRESSION
    (9) EXPRESSION -> EXPRESSION . DIVIDE EXPRESSION
    (10) EXPRESSION -> EXPRESSION . ASSIGN EXPRESSION

    RBRACKET        shift and go to state 18
    PLUS            shift and go to state 7
    MINUS           shift and go to state 8
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 10
    ASSIGN          shift and go to state 11


state 13

    (6) EXPRESSION -> EXPRESSION PLUS EXPRESSION .
    (6) EXPRESSION -> EXPRESSION . PLUS EXPRESSION
    (7) EXPRESSION -> EXPRESSION . MINUS EXPRESSION
    (8) EXPRESSION -> EXPRESSION . TIMES EXPRESSION
    (9) EXPRESSION -> EXPRESSION . DIVIDE EXPRESSION
    (10) EXPRESSION -> EXPRESSION . ASSIGN EXPRESSION

    PLUS            reduce using rule 6 (EXPRESSION -> EXPRESSION PLUS EXPRESSION .)
    MINUS           reduce using rule 6 (EXPRESSION -> EXPRESSION PLUS EXPRESSION .)
    ASSIGN          reduce using rule 6 (EXPRESSION -> EXPRESSION PLUS EXPRESSION .)
    $end            reduce using rule 6 (EXPRESSION -> EXPRESSION PLUS EXPRESSION .)
    RBRACKET        reduce using rule 6 (EXPRESSION -> EXPRESSION PLUS EXPRESSION .)
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 10

  ! TIMES           [ reduce using rule 6 (EXPRESSION -> EXPRESSION PLUS EXPRESSION .) ]
  ! DIVIDE          [ reduce using rule 6 (EXPRESSION -> EXPRESSION PLUS EXPRESSION .) ]
  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]
  ! ASSIGN          [ shift and go to state 11 ]


state 14

    (7) EXPRESSION -> EXPRESSION MINUS EXPRESSION .
    (6) EXPRESSION -> EXPRESSION . PLUS EXPRESSION
    (7) EXPRESSION -> EXPRESSION . MINUS EXPRESSION
    (8) EXPRESSION -> EXPRESSION . TIMES EXPRESSION
    (9) EXPRESSION -> EXPRESSION . DIVIDE EXPRESSION
    (10) EXPRESSION -> EXPRESSION . ASSIGN EXPRESSION

    PLUS            reduce using rule 7 (EXPRESSION -> EXPRESSION MINUS EXPRESSION .)
    MINUS           reduce using rule 7 (EXPRESSION -> EXPRESSION MINUS EXPRESSION .)
    ASSIGN          reduce using rule 7 (EXPRESSION -> EXPRESSION MINUS EXPRESSION .)
    $end            reduce using rule 7 (EXPRESSION -> EXPRESSION MINUS EXPRESSION .)
    RBRACKET        reduce using rule 7 (EXPRESSION -> EXPRESSION MINUS EXPRESSION .)
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 10

  ! TIMES           [ reduce using rule 7 (EXPRESSION -> EXPRESSION MINUS EXPRESSION .) ]
  ! DIVIDE          [ reduce using rule 7 (EXPRESSION -> EXPRESSION MINUS EXPRESSION .) ]
  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]
  ! ASSIGN          [ shift and go to state 11 ]


state 15

    (8) EXPRESSION -> EXPRESSION TIMES EXPRESSION .
    (6) EXPRESSION -> EXPRESSION . PLUS EXPRESSION
    (7) EXPRESSION -> EXPRESSION . MINUS EXPRESSION
    (8) EXPRESSION -> EXPRESSION . TIMES EXPRESSION
    (9) EXPRESSION -> EXPRESSION . DIVIDE EXPRESSION
    (10) EXPRESSION -> EXPRESSION . ASSIGN EXPRESSION

    PLUS            reduce using rule 8 (EXPRESSION -> EXPRESSION TIMES EXPRESSION .)
    MINUS           reduce using rule 8 (EXPRESSION -> EXPRESSION TIMES EXPRESSION .)
    TIMES           reduce using rule 8 (EXPRESSION -> EXPRESSION TIMES EXPRESSION .)
    DIVIDE          reduce using rule 8 (EXPRESSION -> EXPRESSION TIMES EXPRESSION .)
    ASSIGN          reduce using rule 8 (EXPRESSION -> EXPRESSION TIMES EXPRESSION .)
    $end            reduce using rule 8 (EXPRESSION -> EXPRESSION TIMES EXPRESSION .)
    RBRACKET        reduce using rule 8 (EXPRESSION -> EXPRESSION TIMES EXPRESSION .)

  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]
  ! TIMES           [ shift and go to state 9 ]
  ! DIVIDE          [ shift and go to state 10 ]
  ! ASSIGN          [ shift and go to state 11 ]


state 16

    (9) EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .
    (6) EXPRESSION -> EXPRESSION . PLUS EXPRESSION
    (7) EXPRESSION -> EXPRESSION . MINUS EXPRESSION
    (8) EXPRESSION -> EXPRESSION . TIMES EXPRESSION
    (9) EXPRESSION -> EXPRESSION . DIVIDE EXPRESSION
    (10) EXPRESSION -> EXPRESSION . ASSIGN EXPRESSION

    PLUS            reduce using rule 9 (EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .)
    MINUS           reduce using rule 9 (EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .)
    TIMES           reduce using rule 9 (EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .)
    DIVIDE          reduce using rule 9 (EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .)
    ASSIGN          reduce using rule 9 (EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .)
    $end            reduce using rule 9 (EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .)
    RBRACKET        reduce using rule 9 (EXPRESSION -> EXPRESSION DIVIDE EXPRESSION .)

  ! PLUS            [ shift and go to state 7 ]
  ! MINUS           [ shift and go to state 8 ]
  ! TIMES           [ shift and go to state 9 ]
  ! DIVIDE          [ shift and go to state 10 ]
  ! ASSIGN          [ shift and go to state 11 ]


state 17

    (10) EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .
    (6) EXPRESSION -> EXPRESSION . PLUS EXPRESSION
    (7) EXPRESSION -> EXPRESSION . MINUS EXPRESSION
    (8) EXPRESSION -> EXPRESSION . TIMES EXPRESSION
    (9) EXPRESSION -> EXPRESSION . DIVIDE EXPRESSION
    (10) EXPRESSION -> EXPRESSION . ASSIGN EXPRESSION

    $end            reduce using rule 10 (EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .)
    RBRACKET        reduce using rule 10 (EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .)
    PLUS            shift and go to state 7
    MINUS           shift and go to state 8
    TIMES           shift and go to state 9
    DIVIDE          shift and go to state 10
    ASSIGN          shift and go to state 11

  ! PLUS            [ reduce using rule 10 (EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .) ]
  ! MINUS           [ reduce using rule 10 (EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .) ]
  ! TIMES           [ reduce using rule 10 (EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .) ]
  ! DIVIDE          [ reduce using rule 10 (EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .) ]
  ! ASSIGN          [ reduce using rule 10 (EXPRESSION -> EXPRESSION ASSIGN EXPRESSION .) ]


state 18

    (2) EXPRESSION -> LBRACKET EXPRESSION RBRACKET .

    PLUS            reduce using rule 2 (EXPRESSION -> LBRACKET EXPRESSION RBRACKET .)
    MINUS           reduce using rule 2 (EXPRESSION -> LBRACKET EXPRESSION RBRACKET .)
    TIMES           reduce using rule 2 (EXPRESSION -> LBRACKET EXPRESSION RBRACKET .)
    DIVIDE          reduce using rule 2 (EXPRESSION -> LBRACKET EXPRESSION RBRACKET .)
    ASSIGN          reduce using rule 2 (EXPRESSION -> LBRACKET EXPRESSION RBRACKET .)
    $end            reduce using rule 2 (EXPRESSION -> LBRACKET EXPRESSION RBRACKET .)
    RBRACKET        reduce using rule 2 (EXPRESSION -> LBRACKET EXPRESSION RBRACKET .)

